/*
 * This file is part of the MicroPython project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2017, 2018 Rami Ali
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

// ==============================================================================
// Câ†”JavaScript Bridge for CircuitPython WASM Port
// ==============================================================================
// This file defines functions that C code can call to interact with JavaScript.
// All state is stored in C (common-hal and supervisor) - JavaScript just
// reads/writes that memory directly via pointers.
//
// This follows CircuitPython's architecture: common-hal is the hardware layer,
// and for WASM, "hardware" = memory arrays accessible to JavaScript.

mergeInto(LibraryManager.library, {
    // ==========================================================================
    // Virtual Clock (from supervisor/port.c)
    // ==========================================================================
    // The supervisor stores virtual_clock_hw in supervisor/port.c
    // JavaScript writes to ticks_32khz to advance virtual time

    mp_js_ticks_ms__postset: `
        var virtualClockPtr = null;
        var cachedHeapBuffer = null;

        function initVirtualClock() {
            if (virtualClockPtr === null) {
                try {
                    virtualClockPtr = Module.ccall('get_virtual_clock_hw_ptr', 'number', [], []);
                } catch (e) {
                    console.warn('Virtual clock not available, falling back to Date.now():', e);
                }
            }
        }

        function getVirtualClockView() {
            if (virtualClockPtr === null) return null;
            if (cachedHeapBuffer !== Module.HEAPU8.buffer) {
                cachedHeapBuffer = Module.HEAPU8.buffer;
            }
            // virtual_clock_hw_t: uint64 ticks_32khz + uint32 cpu_freq + uint8 mode + uint64 yields + uint64 js_ticks
            return new DataView(cachedHeapBuffer, virtualClockPtr, 32);
        }

        var MP_JS_EPOCH = Date.now();
    `,

    mp_js_ticks_ms: () => {
        if (virtualClockPtr === null) initVirtualClock();

        if (virtualClockPtr !== null) {
            try {
                const view = getVirtualClockView();
                if (view !== null) {
                    const ticks32kHzLow = view.getUint32(0, true);
                    const ticks32kHzHigh = view.getUint32(4, true);
                    const ticks32kHz = (BigInt(ticks32kHzHigh) << 32n) | BigInt(ticks32kHzLow);
                    return Number(ticks32kHz / 32n);  // Convert 32kHz to milliseconds
                }
            } catch (e) {
                console.warn('Error reading virtual clock:', e);
            }
        }

        return Date.now() - MP_JS_EPOCH;
    },

    mp_js_time_ms: () => {
        if (virtualClockPtr === null) initVirtualClock();

        if (virtualClockPtr !== null) {
            try {
                const view = getVirtualClockView();
                if (view !== null) {
                    const ticks32kHzLow = view.getUint32(0, true);
                    const ticks32kHzHigh = view.getUint32(4, true);
                    const ticks32kHz = (BigInt(ticks32kHzHigh) << 32n) | BigInt(ticks32kHzLow);
                    return MP_JS_EPOCH + Number(ticks32kHz / 32n);
                }
            } catch (e) {
                console.warn('Error reading virtual clock for time_ms:', e);
            }
        }

        return Date.now();
    },

    // ==========================================================================
    // Node.js Hook (from MicroPython)
    // ==========================================================================

    mp_js_hook: () => {
        if (ENVIRONMENT_IS_NODE) {
            const mp_interrupt_char = Module.ccall("mp_hal_get_interrupt_char", "number", ["number"], ["null"]);
            const fs = require("fs");
            const buf = Buffer.alloc(1);
            try {
                const n = fs.readSync(process.stdin.fd, buf, 0, 1);
                if (n > 0) {
                    if (buf[0] === mp_interrupt_char) {
                        Module.ccall("mp_sched_keyboard_interrupt", "null", ["null"], ["null"]);
                    } else {
                        process.stdout.write(String.fromCharCode(buf[0]));
                    }
                }
            } catch (e) {
                if (e.code !== "EAGAIN") {
                    throw e;
                }
            }
        }
    },

    // ==========================================================================
    // Cryptographic Random (from MicroPython)
    // ==========================================================================

    mp_js_random_u32__postset:
        "if (globalThis.crypto === undefined) { globalThis.crypto = require('crypto'); }",

    mp_js_random_u32: () =>
        globalThis.crypto.getRandomValues(new Uint32Array(1))[0],

    // ==========================================================================
    // GPIO State Access (from common-hal/digitalio/DigitalInOut.c)
    // ==========================================================================

    mp_js_gpio: () => {},  // Placeholder for postset initialization

    mp_js_gpio__postset: `
        var gpioStatePtr = null;
        function initGPIOState() {
            if (gpioStatePtr === null) {
                try {
                    gpioStatePtr = Module.ccall('get_gpio_state_ptr', 'number', [], []);
                } catch (e) {
                    console.warn('GPIO state not available:', e);
                }
            }
        }
        // gpio_pin_state_t is stored in common-hal/digitalio/DigitalInOut.c
        // Struct size may be padded - use 8 bytes per pin to be safe
        function getGPIOPinView(pin) {
            if (gpioStatePtr === null || pin >= 64) return null;
            return new DataView(Module.HEAPU8.buffer, gpioStatePtr + pin * 8, 8);
        }
    `,

    mp_js_gpio_get_value: (pin) => {
        if (gpioStatePtr === null) initGPIOState();
        const view = getGPIOPinView(pin);
        return view ? view.getUint8(0) : 0;  // Read 'value' field
    },

    mp_js_gpio_set_input_value: (pin, value) => {
        if (gpioStatePtr === null) initGPIOState();
        const view = getGPIOPinView(pin);
        if (view && view.getUint8(1) === 0) {  // Only if direction == input
            view.setUint8(0, value ? 1 : 0);
        }
    },

    mp_js_gpio_get_direction: (pin) => {
        if (gpioStatePtr === null) initGPIOState();
        const view = getGPIOPinView(pin);
        return view ? view.getUint8(1) : 0;  // Read 'direction' field
    },

    // ==========================================================================
    // Analog State Access (from common-hal/analogio/AnalogIn.c)
    // ==========================================================================

    mp_js_analog: () => {},  // Placeholder for postset initialization

    mp_js_analog__postset: `
        var analogStatePtr = null;
        function initAnalogState() {
            if (analogStatePtr === null) {
                try {
                    analogStatePtr = Module.ccall('get_analog_state_ptr', 'number', [], []);
                } catch (e) {
                    console.warn('Analog state not available:', e);
                }
            }
        }
        // analog_pin_state_t: uint16 value + bool is_output + bool enabled = 4 bytes
        function getAnalogPinView(pin) {
            if (analogStatePtr === null || pin >= 64) return null;
            return new DataView(Module.HEAPU8.buffer, analogStatePtr + pin * 4, 4);
        }
    `,

    mp_js_analog_get_value: (pin) => {
        if (analogStatePtr === null) initAnalogState();
        const view = getAnalogPinView(pin);
        return view ? view.getUint16(0, true) : 0;
    },

    mp_js_analog_set_input_value: (pin, value) => {
        if (analogStatePtr === null) initAnalogState();
        const view = getAnalogPinView(pin);
        if (view && !view.getUint8(2)) {  // Only if is_output == false (ADC)
            view.setUint16(0, value, true);
        }
    },
});
